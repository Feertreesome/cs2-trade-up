import { execFile } from "node:child_process";
import { writeFile } from "node:fs/promises";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import prettier from "prettier";

const SOURCE_URL = "https://raw.githubusercontent.com/ByMykel/CSGO-API/main/public/api/en/skins.json";

interface RemoteSkin {
  name: string;
  min_float?: number | null;
  max_float?: number | null;
  rarity?: { name?: string | null } | null;
  collections?: Array<{ name?: string | null } | null> | null;
}

type FloatRange = {
  baseName: string;
  minFloat: number;
  maxFloat: number;
};

interface CollectionFloatCatalogEntry {
  id: string;
  name: string;
  covert: FloatRange[];
  classified: FloatRange[];
}

const execFileAsync = (file: string, args: string[]) =>
  new Promise<{ stdout: string; stderr: string }>((resolvePromise, rejectPromise) => {
    const child = execFile(
      file,
      args,
      { encoding: "utf8", maxBuffer: 16 * 1024 * 1024 },
      (error, stdout, stderr) => {
        if (error) {
          rejectPromise(error);
          return;
        }
        resolvePromise({ stdout, stderr });
      },
    );
    child.stdin?.end();
  });

const slugify = (value: string): string =>
  value
    .normalize("NFKD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/[^a-zA-Z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .toLowerCase();

const parseFloatOr = (value: unknown, fallback: number): number => {
  const parsed = typeof value === "number" ? value : Number(value);
  return Number.isFinite(parsed) ? parsed : fallback;
};

const fetchJson = async <T>(url: string): Promise<T> => {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to fetch ${url}: ${response.status}`);
    return (await response.json()) as T;
  } catch (error) {
    console.warn(`Primary fetch failed, falling back to curl: ${String(error)}`);
    const { stdout } = await execFileAsync("curl", ["-sL", url]);
    return JSON.parse(stdout) as T;
  }
};

const buildCatalog = (skins: RemoteSkin[]): CollectionFloatCatalogEntry[] => {
  const catalog = new Map<string, CollectionFloatCatalogEntry>();

  for (const skin of skins) {
    const rarityName = skin?.rarity?.name;
    if (rarityName !== "Covert" && rarityName !== "Classified") continue;
    if (!Array.isArray(skin.collections) || !skin.collections.length) continue;

    const minFloat = parseFloatOr(skin.min_float, 0);
    const maxFloat = parseFloatOr(skin.max_float, 1);
    const baseName = skin.name?.trim();
    if (!baseName) continue;

    for (const collection of skin.collections) {
      const collectionName = collection?.name?.trim();
      if (!collectionName) continue;

      const collectionId = slugify(collectionName);
      if (!collectionId) continue;

      let entry = catalog.get(collectionName);
      if (!entry) {
        entry = { id: collectionId, name: collectionName, covert: [], classified: [] };
        catalog.set(collectionName, entry);
      }

      const targetList = rarityName === "Classified" ? entry.classified : entry.covert;
      const existing = targetList.find((item) => item.baseName === baseName);
      if (existing) {
        existing.minFloat = Math.min(existing.minFloat, minFloat);
        existing.maxFloat = Math.max(existing.maxFloat, maxFloat);
        continue;
      }

      targetList.push({
        baseName,
        minFloat,
        maxFloat,
      });
    }
  }

  const sorted = Array.from(catalog.values()).sort((a, b) => a.name.localeCompare(b.name));
  for (const entry of sorted) {
    entry.covert.sort((a, b) => a.baseName.localeCompare(b.baseName));
    entry.classified.sort((a, b) => a.baseName.localeCompare(b.baseName));
  }
  return sorted;
};

const formatFile = async (entries: CollectionFloatCatalogEntry[]): Promise<string> => {
  const timestamp = new Date().toISOString();
  const dataLiteral = JSON.stringify(entries, null, 2);
  const content = `/**
 * This file is auto-generated by scripts/syncCollectionFloats.ts.
 * Last updated: ${timestamp}
 * Source: ${SOURCE_URL}
 */
export interface CollectionFloatRange {
  /** Базовое название скина без указания износа. */
  baseName: string;
  /** Минимальное возможное значение float для данного скина. */
  minFloat: number;
  /** Максимальное возможное значение float для данного скина. */
  maxFloat: number;
}

export type CovertFloatRange = CollectionFloatRange;

export type ClassifiedFloatRange = CollectionFloatRange;

export interface CollectionFloatCatalogEntry {
  /** Удобный идентификатор коллекции (kebab-case). */
  id: string;
  /** Человекочитаемое название коллекции. */
  name: string;
  /** Список Covert-предметов и их диапазонов float. */
  covert: CovertFloatRange[];
  /** Список Classified-предметов и их диапазонов float. */
  classified: ClassifiedFloatRange[];
}

export const COLLECTIONS_WITH_FLOAT: CollectionFloatCatalogEntry[] = ${dataLiteral};

export const COLLECTIONS_WITH_FLOAT_MAP = new Map<string, CollectionFloatCatalogEntry>();

export const COLLECTIONS_WITH_FLOAT_BY_NAME = new Map<string, CollectionFloatCatalogEntry>();

export const COVERT_FLOAT_BY_BASENAME = new Map<string, CovertFloatRange>();

export const CLASSIFIED_FLOAT_BY_BASENAME = new Map<string, ClassifiedFloatRange>();

export const rebuildCollectionFloatCaches = (
  entries: CollectionFloatCatalogEntry[] = COLLECTIONS_WITH_FLOAT,
): void => {
  COLLECTIONS_WITH_FLOAT_MAP.clear();
  COLLECTIONS_WITH_FLOAT_BY_NAME.clear();
  COVERT_FLOAT_BY_BASENAME.clear();
  CLASSIFIED_FLOAT_BY_BASENAME.clear();

  for (const entry of entries) {
    COLLECTIONS_WITH_FLOAT_MAP.set(entry.id, entry);
    COLLECTIONS_WITH_FLOAT_BY_NAME.set(entry.name.toLowerCase(), entry);
    for (const covert of entry.covert) {
      COVERT_FLOAT_BY_BASENAME.set(covert.baseName, covert);
    }
    for (const classified of entry.classified) {
      CLASSIFIED_FLOAT_BY_BASENAME.set(classified.baseName, classified);
    }
  }
};

rebuildCollectionFloatCaches();
`;

  return prettier.format(content, { parser: "typescript" });
};

const main = async () => {
  const skins = await fetchJson<RemoteSkin[]>(SOURCE_URL);
  const catalog = buildCatalog(skins);
  if (!catalog.length) throw new Error("No collections with Covert skins found");

  const fileContent = await formatFile(catalog);
  const __dirname = dirname(fileURLToPath(import.meta.url));
  const targetPath = resolve(__dirname, "../data/CollectionsWithFloat.ts");
  await writeFile(targetPath, fileContent, "utf8");
  console.log(`Updated ${targetPath} with ${catalog.length} collections`);
};

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
