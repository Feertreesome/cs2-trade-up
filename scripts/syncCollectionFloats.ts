import { promises as fs } from "node:fs";
import path from "node:path";
import { execFile } from "node:child_process";
import { promisify } from "node:util";

const execFileAsync = promisify(execFile);

const DATA_URL = "https://raw.githubusercontent.com/ByMykel/CSGO-API/main/public/api/en/skins.json";

interface RawCollection {
  id?: string;
  name?: string;
}

interface RawSkin {
  id: string;
  name: string;
  min_float?: number;
  max_float?: number;
  rarity?: { name?: string };
  collections?: RawCollection[];
}

interface CollectionFloatCatalogEntry {
  id: string;
  name: string;
  skins: Array<{
    id: string;
    name: string;
    minFloat: number;
    maxFloat: number;
  }>;
}

const kebabCase = (value: string): string =>
  value
    .normalize("NFKD")
    .replace(/[^\p{Letter}\p{Number}]+/gu, "-")
    .replace(/(^-|-$)+/g, "")
    .replace(/-{2,}/g, "-")
    .toLowerCase();

const buildFileContents = (entries: CollectionFloatCatalogEntry[]): string => {
  const dataLiteral = JSON.stringify(entries, null, 2);

  return `/**
 * Auto-generated file. Do not edit manually.
 * Generated by scripts/syncCollectionFloats.ts
 */

export interface CollectionFloatCatalogEntry {
  id: string;
  name: string;
  skins: Array<{
    id: string;
    name: string;
    minFloat: number;
    maxFloat: number;
  }>;
}

export const COLLECTIONS_WITH_FLOAT: CollectionFloatCatalogEntry[] = ${dataLiteral};

export const COLLECTIONS_WITH_FLOAT_MAP: Record<string, CollectionFloatCatalogEntry> = Object.fromEntries(
  COLLECTIONS_WITH_FLOAT.map((collection) => [collection.id, collection]),
);

export const COLLECTIONS_WITH_FLOAT_BY_NAME: Record<string, CollectionFloatCatalogEntry> = Object.fromEntries(
  COLLECTIONS_WITH_FLOAT.map((collection) => [collection.name, collection]),
);

export interface CovertFloatEntry {
  collectionId: string;
  collectionName: string;
  minFloat: number;
  maxFloat: number;
}

export const COVERT_FLOAT_BY_BASENAME: Record<string, CovertFloatEntry> = Object.fromEntries(
  COLLECTIONS_WITH_FLOAT.flatMap((collection) =>
    collection.skins.map((skin) => [
      skin.name,
      {
        collectionId: collection.id,
        collectionName: collection.name,
        minFloat: skin.minFloat,
        maxFloat: skin.maxFloat,
      },
    ]),
  ),
);
`;
};

const loadDataset = async (): Promise<RawSkin[]> => {
  try {
    const response = await fetch(DATA_URL);
    if (!response.ok) {
      throw new Error(`Failed to load skins dataset: ${response.status} ${response.statusText}`);
    }
    return (await response.json()) as RawSkin[];
  } catch (error) {
    console.warn(`Fetch failed (${String((error as Error).message)}), falling back to curl...`);
    const { stdout } = await execFileAsync("curl", ["-sL", DATA_URL], {
      maxBuffer: 1024 * 1024 * 32,
    });
    return JSON.parse(stdout) as RawSkin[];
  }
};

const main = async () => {
  const payload = await loadDataset();

  const collectionMap = new Map<string, CollectionFloatCatalogEntry>();

  for (const skin of payload) {
    if (skin.rarity?.name !== "Covert") continue;
    if (!skin.collections || !skin.collections.length) continue;

    for (const collection of skin.collections) {
      const collectionName = collection?.name?.trim();
      if (!collectionName) continue;
      const collectionId = kebabCase(collectionName);
      if (!collectionId) continue;

      const minFloat = typeof skin.min_float === "number" ? skin.min_float : 0;
      const maxFloat = typeof skin.max_float === "number" ? skin.max_float : 1;

      if (!collectionMap.has(collectionId)) {
        collectionMap.set(collectionId, {
          id: collectionId,
          name: collectionName,
          skins: [],
        });
      }

      const entry = collectionMap.get(collectionId)!;
      const alreadyPresent = entry.skins.some(
        (existing) => existing.id === skin.id || existing.name === skin.name,
      );
      if (alreadyPresent) continue;

      entry.skins.push({
        id: skin.id,
        name: skin.name,
        minFloat,
        maxFloat,
      });
    }
  }

  const sortedEntries = Array.from(collectionMap.values())
    .map((entry) => ({
      ...entry,
      skins: entry.skins.slice().sort((a, b) => a.name.localeCompare(b.name, "en")),
    }))
    .sort((a, b) => a.name.localeCompare(b.name, "en"));

  const filePath = path.resolve(process.cwd(), "data", "CollectionsWithFloat.ts");
  const fileContents = buildFileContents(sortedEntries);
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, fileContents, "utf8");
  console.log(`Wrote ${sortedEntries.length} collections to ${filePath}`);
};

void main();
